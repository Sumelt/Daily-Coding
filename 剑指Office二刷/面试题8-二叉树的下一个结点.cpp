/*struct TreeLinkNode {    int val;    struct TreeLinkNode *left;    struct TreeLinkNode *right;    struct TreeLinkNode *next;    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {            }};*/class Solution {public:    TreeLinkNode* GetNext(TreeLinkNode* pNode)    {        if( pNode == nullptr )       		return nullptr;		//情况一：该节点存在右子树		if( pNode->right != nullptr ) {			pNode = pNode->right;			while( pNode->left != nullptr ) 				pNode = pNode->left;			return pNode;		} 		//不存在右子树 		else {			//情况二：该节点为它父亲节点的左节点			if( pNode->next != nullptr && pNode->next->left == pNode ) 				return pNode->next;							//情况三：该节点为它父亲节点的右节点			//下一个节点为回溯一个节点为它父亲节点的左节点			//该节点的父亲节点就是要返回的节点 			else if( pNode->next != nullptr && pNode->next->right == pNode ) {				pNode = pNode->next;				while( pNode->next != nullptr && pNode->next->left != pNode )					pNode = pNode->next;				if( pNode->next != nullptr && pNode->next->left == pNode )					return pNode->next;							}		} 		return nullptr;		     }};