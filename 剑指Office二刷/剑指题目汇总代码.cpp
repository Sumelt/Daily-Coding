//数组中重复的数字//在一个长度为n的数组里的所有数字都在0到n-1的范围内。 //数组中某些数字是重复的，但不知道有几个数字是重复的。//也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 //例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2//方法：交换法class Solution {public:    // Parameters:    //        numbers:     an array of integers    //        length:      the length of array numbers    //        duplication: (Output) the duplicated number in the array number    // Return value:       true if the input is valid, and there are some duplications in the array number    //                     otherwise false    bool duplicate(int numbers[], int length, int* duplication) {        //必要的条件检查		if( length <= 0 || numbers == nullptr )            return false;        for( int i = 0; i < length; ++i )            if( numbers[ i ] >= length || numbers[ i ] < 0 )                return false;		//核心代码        for( int i = 0; i < length; ++i ) {            while( numbers[ i ] != i ) {                if( numbers[ numbers[ i ] ] != numbers[ i ] )//对应位置的元素不符合条件                    swap( numbers[ i ], numbers[ numbers[ i ] ] );                else { //否则对应元素的位置符合条件，则表明找到重复元素                    *duplication = numbers[ i ];                    return true;                }            }        }        return false;    }};//数组中重复的数字//不修改数组情况下，找出任意一个重复的数字，N个数字范围都是在1~N，N+1个长度的数组//方法：二分法//时间复杂度为O（nlogn）class Solution {private:	int calCount( int *numbers, int length, int leftInterval, int rightInterval ) {		if( numbers == nullptr || length <= 0 )			return 0;		int size = 0;		//统计【leftInterval, rightInterval】区间内符合要求的区间个数		for( int i = 0; i < length; ++i )			if( numbers[ i ] >= leftInterval && numbers[ i ] <= rightInterval )				++size;		return size;	}public:    int duplicate( int numbers[], int length ) {        if( numbers == nullptr || length <= 0 )			return 0;				int letf = 0, right = length - 1;				while( left <= right ) {			int mid = ( left + right ) >> 1;			int sumSize = calCount( numbers, length, left, mid );						if( right == left ) { //合法区间只有一个元素的情况下				if( sumSize > 1 )					return right;				else break;			}			else if( sumSize > ( mid - left + 1 ) )				right = mid;			else left = mid + 1;//区间右移要加1					}		return -1;    }};//二维数组中的查找//在一个二维数组中（每个一维数组的长度相同）//每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。//请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数//方法：排除行排除列交替进行，类似十字确定目标。可以从右上角或者从左下角进行切入class Solution {public:    bool Find(int target, vector<vector<int> > array) {        if( array.size() <= 0 )            return false;        int rows = array.size() - 1;        int cols = array[ 0 ].size() - 1;        int row = 0;        for( int col = cols; col >= 0; --col ) {//切换列            for( ; row <= rows; ++row ) {//切换行                if( array[ row ][ col ] > target )                    break;                else if( array[ row ][ col ] == target )                    return true;            }        }        return false;    }};