/*****************************数组******************************************///数组中重复的数字 0到n-1//在一个长度为n的数组里的所有数字都在0到n-1的范围内。 //数组中某些数字是重复的，但不知道有几个数字是重复的。//也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 //例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2//方法：交换法class Solution {public:    // Parameters:    //        numbers:     an array of integers    //        length:      the length of array numbers    //        duplication: (Output) the duplicated number in the array number    // Return value:       true if the input is valid, and there are some duplications in the array number    //                     otherwise false    bool duplicate(int numbers[], int length, int* duplication) {        //必要的条件检查		if( length <= 0 || numbers == nullptr )            return false;        for( int i = 0; i < length; ++i )            if( numbers[ i ] >= length || numbers[ i ] < 0 )                return false;		//核心代码        for( int i = 0; i < length; ++i ) {            while( numbers[ i ] != i ) {                if( numbers[ numbers[ i ] ] != numbers[ i ] )//对应位置的元素不符合条件                    swap( numbers[ i ], numbers[ numbers[ i ] ] );                else { //否则对应元素的位置符合条件，则表明找到重复元素                    *duplication = numbers[ i ];                    return true;                }            }        }        return false;    }};//数组中重复的数字 1到n//不修改数组情况下，找出任意一个重复的数字，N个数字范围都是在1~N，N+1个长度的数组//方法：二分法//时间复杂度为O（nlogn）class Solution {private:	int calCount( int *numbers, int length, int leftInterval, int rightInterval ) {		if( numbers == nullptr || length <= 0 )			return 0;		int size = 0;		//统计【leftInterval, rightInterval】区间内符合要求的区间个数		for( int i = 0; i < length; ++i )			if( numbers[ i ] >= leftInterval && numbers[ i ] <= rightInterval )				++size;		return size;	}public:    int duplicate( int numbers[], int length ) {        if( numbers == nullptr || length <= 0 )			return 0;				int letf = 0, right = length - 1;				while( left <= right ) {			int mid = ( left + right ) >> 1;			int sumSize = calCount( numbers, length, left, mid );						if( right == left ) { //合法区间只有一个元素的情况下				if( sumSize > 1 )					return right;				else break;			}			else if( sumSize > ( mid - left + 1 ) )				right = mid;			else left = mid + 1;//区间右移要加1					}		return -1;    }};//二维数组中的查找//在一个二维数组中（每个一维数组的长度相同）//每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。//请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数//方法：排除行排除列交替进行，类似十字确定目标。可以从右上角或者从左下角进行切入class Solution {public:    bool Find(int target, vector<vector<int> > array) {        if( array.size() <= 0 )            return false;        int rows = array.size() - 1;        int cols = array[ 0 ].size() - 1;        int row = 0;        for( int col = cols; col >= 0; --col ) {//切换列            for( ; row <= rows; ++row ) {//切换行                if( array[ row ][ col ] > target )                    break;                else if( array[ row ][ col ] == target )                    return true;            }        }        return false;    }};//数组中出现次数超过一半的数字//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。//例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。//由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。//方法1：快排归位(次数超过一半的数字必然是中位数)，找到中位数即可，需要检测次数超过数组的一半//方法2：记录数字出现的次数，最后次数仍然大于等于1的数可能是中位数，需要检测次数超过数组的一半class Solution {private:    bool checkTime( vector<int> &numbers, int target ) {        int size = 0;        for( auto value : numbers )            if( value == target )                ++size;        if( size * 2 > numbers.size() )            return true;        else return false;    }public:    //方法2实现	int MoreThanHalfNum_Solution(vector<int> numbers) {        if( numbers.size() == 0 )            return 0;                int number = 0, time = 0;        for( int i = 0; i < numbers.size(); ++i ) {            //保存当前的元素			if( time == 0 ) {                number = numbers[ i ];                time = 1;            }            else if( number == numbers[ i ] )                ++time;            else --time;        }        if( time >= 1 && checkTime( numbers, number ) )//检查是否符合要求            return number;        return 0;    }};//连续子数组的最大和//方法：暂存当前累计值和最大值做比较class Solution {public:    int FindGreatestSumOfSubArray(vector<int> array) {        if( array.size() == 0 )            return 0;        int curSum = 0;        int max = INT_MIN;        for( auto value : array ) {            if( curSum <= 0 )//丢弃之前的累计值重新开始                curSum = value;            else curSum += value;			            if( curSum > max )//作比较                max = curSum;        }        return max;    }};//数字在排序数组中出现的次数//统计一个数字在排序数组中出现的次数//方法：只要找出该数字第一次出现的下标和最后一次出现的下标，两者相减+1即可class Solution {private:    int retFirstIndex( vector<int> &data, int k, int beginIndex, int endIndex ) {        if( beginIndex > endIndex ) return -1; //找不到则返回-1，因为0是有效数字		        int midIndex = ( beginIndex + endIndex ) >> 1;        if( data[ midIndex ] == k ) {            if( midIndex == 0 || ( midIndex > 0 && data[ midIndex - 1 ] != k ) )                return midIndex;            //else 前一位数字也相等，则继续向前折半        }        if( data[ midIndex ] < k )            beginIndex = midIndex + 1;        else endIndex = midIndex - 1;		        return retFirstIndex( data, k, beginIndex, endIndex );    }    int retLastIndex( vector<int> &data, int k, int beginIndex, int endIndex ) {        if( beginIndex > endIndex ) return -1;//找不到则返回-1，因为0是有效数字		        int midIndex = ( beginIndex + endIndex ) >> 1;               if( data[ midIndex ] == k ) {            if( midIndex == data.size() - 1 ||                    ( midIndex < data.size() - 2 && data[ midIndex + 1 ] != k ) )                return midIndex;            //else 后移为数字也相等，则继续向后折半        }                if( data[ midIndex ] > k )            endIndex = midIndex - 1;        else beginIndex = midIndex + 1;		        return retLastIndex( data, k, beginIndex, endIndex );            }public:    int GetNumberOfK(vector<int> data ,int k) {        if( data.size() == 0 )            return 0;        int firstIndex = retFirstIndex( data, k, 0, data.size() - 1 );        int lastIndex = retLastIndex( data, k, 0, data.size() - 1 );        		if( firstIndex > -1 && lastIndex > -1 )//要判断合法性            return lastIndex - firstIndex + 1;			        return 0;    }};//排序数组中数值和下标相等的元素//方法：二分查找法class Solution{public:	int valueSameIndex( int *array, int length ) {		if( length <= 0 )			return -1;				int beginIndex = 0;		int endIndex = length - 1;				while( beginIndex <= endIndex ) {			int midIndex = ( endIndex + beginIndex ) >> 1;			if( array[ midIndex ] == midIndex )				return midIndex;			else if( minIndex > array[ midIndex ] )				endIndex = midIndex - 1;			else beginIndex = midIndex + 1;		}		return -1;	}};//排序数组中 0--n中缺失的数字//方法：二分法class Solution {private:	int findLostNumber( int *array, int beginIndex, int endIndex ) {		if( beginIndex > endIndex )			return -1;				int midIndex = ( beginIndex + endIndex ) >> 1;		if( array[ midIndex ] != midIndex ) {			if( midIndex == 0 || ( midIndex > 0 && array[ midIndex - 1 ] == midIndex - 1 ) )				return midIndex;			//else 向前寻找		}		if( array[ midIndex ] == minIndex )//相等则不断向后寻找			beginIndex = midIndex + 1;		else endIndex = midIndex - 1; //向前寻找				return findLostNumber( array, beginIndex, endIndex );	}public:	int lostNumber( int *array, int length  ) {		if( length <= 0 )			return -1;				int lostNumber = findLostNumber( array, 0, length - 1 );		if( lostNumber != -1 )			return lostNumber;				return -1;	}};//股票的最大利润//方法：购入价最低时，出售价最高时，利润最大，保存之前最低价格和最大利润即可class SOlution {public:	int maxProfit( int *array, int length ) {		if( array == nullptr || length <= 0 )			return 0;				int minPrice = array[ 0 ];		int maxProfit = array[ 1 ] - minPrice;				for( int i = 2; i < length; ++i ) {			if( minPrice > array[ i - 1 ] )				minPrice = array[ i - 1 ];						int curProfit = array[ i ] - minPrice;			if( maxProfit < curProfit )				maxProfit = curProfit;		}		return maxProfit;	}};/*****************************位运算******************************************///计算二进制中1的个数//方法：x & (x-1)运算，每次都能消去x中最后一个1的位数，只要记录调用消去多少个1即可int oneCount( int number ) {	int size = 0;	while( number != 0 ) {		number = number & ( number - 1 );		++size;	}	return size;}//O(1)时间检测某个整数是否是2的幂次//方法：x&( x - 1 ) == 0表示为真bool isPower( int number ) {	if( number <= 0 )		return false;	return ( ( number & ( number - 1 ) == 0 ? true : false ) );}//将整数A改变成整数B 需要改变多少个比特位//方法：区别在于不同的比特位，找出不同的比特位(使用异或)，然后判断二进制1的个数int changeBitCount( int a, int b ) {	int value = a ^ b;	int size = 0;	while( value != 0 ) {		value = value & ( value - 1 );//判断二进制1的个数		++size;	}	return size;}//找出只出现一次，其余出现两次的数//方法：使用异或。相同的数异或为0int appearOneTime( int *array, int length ) {	if( array == nullptr || length <= 0 )		return -1;	int res = 0;	for( int i = 0; i < length; ++i )		res ^= array[ i ];		return res;}//判断是奇数还是偶数//方法：奇数和0x1做与为1，否则为偶数bool isOdd( int number ) {	if( number & 0x01 == 1 )		return true;	else return false;}//找出二进制数中第一个位数不为1的位置//方法：一个数的原码和补码做与即可int findOneIndex( int number ) {	return ( number & ( -number ) );}//数组中除一个数字只出现一次外，其余数字都出现三次，请找出出现一次的数字//方法：用一个32个元素的数组保存比特位出现的次数//出现三次的比特位最后肯定被3整除，剩余的便是出现一次的数字int appearOneTime( int *array, int length ) {	int bitTime[ 32 ] = { 0 };		//保存每一个比特位出现的次数	for( int i = 0; i < length; ++i ) {		int andBit = 1;		for( int bitIndex = 31; bitIndex >= 0; --bitIndex ) {			if( ( andBit & array[ i ] ) == 1 )				++bitTime[ bitIndex ];			andBit <<= 1;		}	}		//结果复原，从高位开始，必须要把上一次的结果向左移位后才累加	int res = 0;	for( int i = 0; i < 32; ++i ) {		res <<= 1;		res += bitTime[ i ] % 3;	}	return res;}//一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出两个出现一次的数//方法：将所有数进行异或，最后的结果就是两个不同的数异或的结果，然后使用第一位为1的比特位将所有数分别拆开class Solution {private:    vector<int>aryOne;    vector<int>aryTwo;public:    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {        if( data.size() == 0 )            return;                int xorRes = 0;        for( auto value : data )            xorRes ^= value;//拿到所有数异或后的结果，该结果为两个只出现1次的数异或结果                int k = 1;        while( ( k & xorRes ) != k )  //找出第一位比特位不为1的数            k <<= 1;                for( auto value : data ) { //利用该位进行拆分            if( ( k & value ) != k )                aryOne.push_back( value );            else aryTwo.push_back( value );        }                int res = 0;        for( auto value : aryOne ) //分别提取            res ^= value;        *num1 = res;                res = 0;        for( auto value : aryTwo ) //分别提取            res ^= value;        *num2 = res;    }};//不用加减乘除做加法//写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号//方法：//第一步先不考虑进位情况，即是使用异或操作，代表相加//第二步考虑进位情况，只有与操作后为1的位数才可能是进位//第三步，把进位加入结果中，即是使用异或操作，代表相加class Solution {public:    int Add(int num1, int num2)    {        int sum = num1 ^ num2;//求和不考虑进位，第一步        int andCarry = ( num1 & num2 ) << 1;//获取进位的情况，同时<< 1表示进位，第二步(1的个数便是进位的次数)                while( andCarry != 0 ) {            num1 = sum;            num2 = andCarry;            sum = num1 ^ num2;//第三步：不进位+进位(便是该位上进位的情况)            andCarry = ( num1 & num2 ) << 1;//消去进位上的1，对下一个1进行进位        }        return sum;    }};