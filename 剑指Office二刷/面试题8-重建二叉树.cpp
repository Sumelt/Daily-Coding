////前序遍历和中序遍历的结果，请重建出该二叉树/** * Definition for binary tree * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {private:	TreeNode* createBinaryTree( vector<int> &pre, vector<int> vin, 		int preStartIndex, int preEndIndex, int vinStartIndex, int vinEndIndex ) {			if( vinStartIndex > vinEndIndex )				return nullptr;			TreeNode *root = new TreeNode( pre[ preStartIndex ] );			int rootIndex = vinStartIndex;			for( ; rootIndex <= vinEndIndex; ++rootIndex )				if( vin[ rootIndex ] == pre[ preStartIndex ] )					break;			int length = rootIndex - vinStartIndex;						root->left = createBinaryTree( pre, vin, preStartIndex + 1, 				preEndIndex, vinStartIndex, rootIndex - 1 );			root->right = createBinaryTree( pre, vin, preStartIndex + length + 1, 				preEndIndex, rootIndex + 1, vinEndIndex );						return root;	}public:    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {		if( pre.size() <=0 || vin.size() <= 0 )			return nullptr;		return createBinaryTree( pre, vin, 			0, pre.size() - 1, 0, vin.size() - 1 );    }};