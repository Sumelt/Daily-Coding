/*----------------------------------------------------------------

* @Author: Su

* @Description: 

* @Creath Date: 

----------------------------------------------------------------*/

#include <iostream>
#include <algorithm>
#include "../random_number.h"
using namespace std;

namespace Binary_search {
template <typename T>
int Binarysearch( T *ary, int size, T target) {
	
	int leftIndex = 0, rightIndex = size - 1;
	while( leftIndex <= rightIndex ) {
		
		int midIndex = leftIndex + ( ( rightIndex - leftIndex ) >> 1 );//避免溢出 
		if( target == ary[ midIndex ] )
			return midIndex;
		if( target > ary[ midIndex ] )
			leftIndex = midIndex + 1;
		else rightIndex = midIndex - 1;
	}
	return -1;
}

// 二分查找法, 在有序数组arr中, 查找target
// 如果找到target, 返回第一个target相应的索引index
// 如果没有找到target, 返回比target小的最大值相应的索引, 如果这个最大值有多个, 返回最大索引
// 如果这个target比整个数组的最小元素值还要小, 则不存在这个target的floor值, 返回-1
template<typename T>
int floor(T arr[], int n, T target){

    assert( n >= 0 );

    // 寻找比target小的最大索引
    int l = -1, r = n-1;
    while( l < r ){
        // 使用向上取整避免死循环
        int mid = l + (r-l+1)/2;
        cout << "floor: mid: " << mid << ' ' << l << ' ' << r << endl;
        if( arr[mid] >= target )//大于等目标值时 
            r = mid - 1; //缩小尾部 
        else
            l = mid;
    }

    assert( l == r );

    // 如果该索引+1就是target本身, 该索引+1即为返回值
    if( l + 1 < n && arr[l+1] == target )
        return l + 1;

    // 否则, 该索引即为返回值
    return l;
}


// 二分查找法, 在有序数组arr中, 查找target
// 如果找到target, 返回最后一个target相应的索引index
// 如果没有找到target, 返回比target大的最小值相应的索引, 如果这个最小值有多个, 返回最小的索引
// 如果这个target比整个数组的最大元素值还要大, 则不存在这个target的ceil值, 返回整个数组元素个数n
template<typename T>
int ceil(T arr[], int n, T target){

	    assert( n >= 0 );
	
	    // 寻找比target大的最小索引值
	    int l = 0, r = n;
	    while( l < r ){
	        // 使用普通的向下取整即可避免死循环
	        int mid = l + (r-l)/2;
	        //cout << "" 
	        if( arr[mid] <= target )
	            l = mid + 1;
	        else // arr[mid] > target
	            r = mid;
	    }
	
	    assert( l == r );
	
	    // 如果该索引-1就是target本身, 该索引+1即为返回值
	    if( r - 1 >= 0 && arr[r-1] == target )
	        return r-1;
	
	    // 否则, 该索引即为返回值
	    return r;
	}
}

int main(int argc, char *argv[])
{
	int length = 20;
	int *ary = Generate_random_numbers( 20, 90, length );
	sort( ary, ary + length );
	
	for( int i = 0; i < length; ++i )
		cout << ary[ i ] << ends;
	cout << endl;
	cout << endl << Binary_search::floor( ary, length, 23 );
	
	return 0;
}