# 网络编程

## 套接字

### CS模型

```cpp
//cshead.h
#ifndef CSHEAD_H
#define CSHEAD_H

#include <iostream>
#include <string>
#include <cstring>
#include <pthread.h>
#include <error.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

using namespace std;

void *client( void *value );
void serve( pthread_t tid );

#endif // CSHEAD_H
```
```cpp
//main.cpp
#include "cshead.h"

int main()
{
    cout << "-------CS start-----" << endl;
    pthread_t tid;
    int getReturn;
    getReturn = pthread_create( &tid, nullptr, client, nullptr );
    if( getReturn ){
        cout << "creathe pthread error\n";
        exit( 0 );
    }

    cout << "------serve start-----" << endl;
    serve( tid );

    return 0;
}
```
**客户端**

```cpp
//client.cpp
#include "cshead.h"
#define MAXSIZE 4096

void *client( void *value )
{
    sleep( 2 );

    int sockfd;
    char sendLine[ MAXSIZE ];
    char serIp[] = "127.0.0.1";//服务器IP地址
    int getReturn;
    struct sockaddr_in seraddr;//套接字结构体

    sockfd = socket( AF_INET, SOCK_STREAM, 0 );
    if( sockfd < 0 ) {
        cout << "socket creath faile from client" << endl;
        exit( 0 );
    }

    memset( &seraddr, 0, sizeof ( seraddr ) );
    seraddr.sin_family = AF_INET;
    seraddr.sin_port = htons( 6666 );//服务器端口号
    getReturn =  inet_pton( AF_INET, serIp, &seraddr.sin_addr );//点十分到二进制转换
    if( getReturn <= 0 ) {
        cout << "inet_pton failefrom client" << endl;
        exit( 1 );
    }

    getReturn = connect( sockfd, ( struct sockaddr* )&seraddr, sizeof ( seraddr ) );//套接字连接，需要进行结构体强制转换
    if( getReturn < 0 ) {
        cout << "connect faile from client" << endl;
        exit( 0 );
    }

    cout << "----Successfully connected to the server " << endl
         << "  please input string send to server---" << endl;
    fgets( sendLine, MAXSIZE, stdin );//获取标准输入
    if( send( sockfd, sendLine, strlen( sendLine ), 0 ) < 0 ) {//向套接字发送数据
        cout << "send faile from client" << endl;
        exit( 0 );
    }
    close( sockfd );//关闭套接字
    pthread_exit( ( void* )0 );
}
```
**服务器**

```cpp
//server.cpp
#include "cshead.h"

#define MaxLINE 4096
#define MaxBuff 4096

void serve( pthread_t tid )
{
    int listenfd, connfd;//监听套接字 连接套接字
    int getReturn;
    char buff[ MaxBuff ];//缓冲区
    ssize_t byteSize;//接收的字节数
    struct sockaddr_in servaddr;//套接字结构体

    listenfd = socket( AF_INET, SOCK_STREAM, 0 );//创建套接字：IPV4协议 TCP套接字 自动选择协议
    if( listenfd == -1 ){
        cout << "creath socket faile from server" << endl;
        exit( 0 );
    }

    memset( &servaddr, 0, sizeof ( servaddr ) );//初始化套接字结构体
    servaddr.sin_family = AF_INET;//IPV4协议
    servaddr.sin_addr.s_addr = htonl( INADDR_ANY );//多网卡
    servaddr.sin_port = htons( 6666 );//服务器端口号

    getReturn =  bind( listenfd, ( struct sockaddr* )&servaddr, sizeof ( servaddr ) );//将结构体信息绑定到该套接字上
    if( getReturn == -1 ){
        cout << "bind socket faile from server" << endl;
        exit( 0 );
    }

    getReturn = listen( listenfd, 10 );//创建监听套接字 监听指定端口的请求，10个请求队列
    if( getReturn == -1 ){
        cout << "listen socket faile from server" << endl;
        exit( 0 );
    }

    cout << "------serve waiting client request---------" << endl;
    int countClient = 0;
    while ( countClient != 1 ) {
        connfd = accept( listenfd, ( struct sockaddr* )nullptr, nullptr );//等待客户端请求，连接成功创建连接套接字
        if( connfd == -1 ){
            cout << "accept faile from server" << endl;
            continue;
        }
        ++countClient;
        byteSize = recv( connfd, buff, MaxLINE, 0 );//利用连接套接字，读取缓冲区的字节数
        buff[ byteSize ] = '\0';
        string receStr( buff );
        cout << "recv msg from client: "<< receStr << endl;
        close( connfd );//关闭连接套接字
        pthread_join( tid, nullptr );//等待子线程退出
    }
    close( listenfd );//关闭监听套接字
}

```



# 进程间通讯

## 共享内存

**写入数据**

```cpp
#include <iostream>
#include "shareMemory.h"
#include <stdlib.h>
#include <cstring>
#include <error.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <unistd.h>

using namespace std;
int main(int argc, char *argv[])
{
    int shmid; //获得的内存ID
    key_t key = ftok( "./", 425 );

    shmid = shmget( key, sizeof( shareMemoryStruct ), 0666 | IPC_CREAT  );//申请一块共享内存
    if( shmid == -1 ) {
        cout << "shmget faile error number: " << endl;
            //<< error( STDERR_FILENO ) << endl;
         exit( EXIT_FAILURE );
    }
    cout << "shared memory address is: "<< shmid << endl;
    void *sharedMermory = NULL; //把该共享内存映射到本进程的地址空间
    sharedMermory = shmat( shmid, 0, 0 );//映射共享内存
    if( sharedMermory == ( void* )-1 ) {
        cout << "shmat faile error number: " << endl;
        exit( EXIT_FAILURE );
    }

    cout << "shared Memory attached at: " << &sharedMermory << endl; //输出映射的地址
    shareMemoryStruct *shMerPtr = ( shareMemoryStruct* )sharedMermory;//获得指向共享内存的指针
    memset( shMerPtr, 0, sizeof( *shMerPtr ) );
    shMerPtr->write = 1;

    char buffer[ MAXSIZE ]; //输入缓冲区
    while( true ) {
        while( shMerPtr->write == 1 ) {
            cout << "waite consume sleep 2 second" << endl; //等待消费者进程启动允许写数据
            sleep( 2 );
        }
        cout << "input string" << endl;
        cin >> buffer; //获取标准输入数据
        strncpy( shMerPtr->buff, buffer, sizeof( buffer ) ); //写到共享内存中
        shMerPtr->write = 1;//消费者进程读取数据标记

        if( strncmp( shMerPtr->buff, "end", 3 ) == 0 ) //结束字符
            break;
    }

    if( shmdt( sharedMermory ) == -1 ) { //分离共享内存映射
        cout << "shmdt faile" << endl;
        exit( EXIT_FAILURE );
    }

    return 0;
}
```

**读取数据**

```cpp
#include <iostream>
#include "shareMemory.h"
#include <stdlib.h>
#include <cstring>
#include <error.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <unistd.h>


using namespace std;
int main(int argc, char *argv[])
{
    int shmid; //获得的内存ID
    key_t key = ftok( "./", 425 );

    shmid = shmget( key, sizeof( shareMemoryStruct ), 0666 | IPC_CREAT  );//申请一块共享内存
    if( shmid == -1 ) {
        cout << "shmget faile error number: " << endl;
            //<< error( STDERR_FILENO ) << endl;
         exit( EXIT_FAILURE );
    }

        void *sharedMermory = NULL; //把该共享内存映射到本进程的地址空间
    sharedMermory = shmat( shmid, 0, 0 );//映射共享内存
    if( sharedMermory == ( void* )-1 ) {
        cout << "shmat faile error number: " << endl;
        exit( EXIT_FAILURE );
    }

    cout << "shared Memory attached at: " << &sharedMermory << endl; //输出映射的地址
    shareMemoryStruct *shMerPtr = ( shareMemoryStruct* )sharedMermory;//获得指向共享内存的指针
    shMerPtr->write = 0;

    while( true ) {
        if( shMerPtr->write == 1 ) {
            write( STDOUT_FILENO, shMerPtr->buff, sizeof( shMerPtr->buff ) );
            cout << endl;
            sleep( 1 );
            shMerPtr->write = 0;
        }
        if( strncmp( shMerPtr->buff, "end", 3 ) == 0 )
            break;
    }

    if( shmdt( sharedMermory ) == -1 ) { //分离共享内存映射
        cout << "shmdt faile" << endl;
        exit( EXIT_FAILURE );
    }

    if ( shmctl( shmid, IPC_RMID, 0 ) == -1 ) {
        cout << "shmctl(IPC_RMID) failed\n";
        exit(EXIT_FAILURE);
    }

    return 0;
}
```



## 信号量

```cpp
#include <iostream>
#include <sys/shm.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

using namespace std;

union semun {
    int val;
};

int main(int argc, char *argv[])
{
    int shmid; //获得的内存ID
    key_t key = ftok( "./", 425 );

    shmid = shmget( key, sizeof( int ), IPC_CREAT | 0666 );
    if( shmid < 0 ) {
        cout << "shmget faile" << endl;
        exit( EXIT_FAILURE );
    }
    cout << "shared memory address is: "<< shmid << endl;

    void *shmemory = shmat( shmid, nullptr, 0 );
    if( shmemory == ( void* ) -1 ) {
        cout << "shmat faile" << endl;
        exit( EXIT_FAILURE );
    }
    cout << "shared Memory attached at: " << &shmemory << endl;

    int *data = ( int* )shmemory;
    *data = -1;

    key_t semKid = ftok( "./", 500 );
    int semid = semget( semKid, 2, IPC_CREAT | 0666 ); //生成2个信号量

    semun semunUnion;
    semunUnion.val = 0;//信号0初值
    semctl( semid, 0, SETVAL, semunUnion );//设置信号0

    semunUnion.val = 1;//信号1初值
    semctl( semid, 1, SETVAL, semunUnion );//设置信号1

    struct sembuf sembufStruct;

    while( true ) {
        sembufStruct.sem_num = 0;//对信号0操作
        sembufStruct.sem_op = -1;//P操作
        sembufStruct.sem_flg = SEM_UNDO;//系统清除信号量
        semop( semid, &sembufStruct, 1 );//读操作造成阻塞

        cout << "you input number is: "<< *data << endl;

        sembufStruct.sem_num = 1;//对信号号1操作
        sembufStruct.sem_op = 1;//V操作
        sembufStruct.sem_flg = SEM_UNDO;
             semop( semid, &sembufStruct, 1 );//写操作

        if( *data == 0 )
            break;
    }

    return 0;
}
```

**写者**

``` cpp
//writer
#include <iostream>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/sem.h>

using namespace std;

union semun {
    int val;
};

int main(int argc, char *argv[])
{
    int shmid; //获得的内存ID
    key_t key = ftok( "./", 425 );

    shmid = shmget( key, sizeof( int ), IPC_CREAT | 0666 );
    if( shmid < 0 ) {
        cout << "shmget faile" << endl;
        exit( EXIT_FAILURE );
    }
    cout << "shared memory address is: "<< shmid << endl;

    void *shmemory = shmat( shmid, nullptr, 0 );
    if( shmemory == ( void* ) -1 ) {
        cout << "shmat faile" << endl;
        exit( EXIT_FAILURE );
    }
    cout << "shared Memory attached at: " << &shmemory << endl;

    int *data = ( int* )shmemory;
    *data = -1;

    key_t semKid = ftok( "./", 500 );
    int semid = semget( semKid, 2,  0666 );

    struct sembuf sembufStruct;
    cout << "input number '0' to end" << endl;
    while( true ) {
        sembufStruct.sem_num = 1;
        sembufStruct.sem_op = -1;
        sembufStruct.sem_flg = SEM_UNDO;
        semop( semid, &sembufStruct, 1 );

        cout << "please input number: ";
        cin >> *data;

        sembufStruct.sem_num = 0;
        sembufStruct.sem_op = 1;
        sembufStruct.sem_flg = SEM_UNDO;
        semop( semid, &sembufStruct, 1 );

        if( *data == 0 )
            break;
    }

    return 0;
}
```



## 消息队列



# 线程间通讯