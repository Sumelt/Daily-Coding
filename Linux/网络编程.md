# 网络编程

## 套接字

### CS模型

```cpp
//cshead.h
#ifndef CSHEAD_H
#define CSHEAD_H

#include <iostream>
#include <string>
#include <cstring>
#include <pthread.h>
#include <error.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

using namespace std;

void *client( void *value );
void serve( pthread_t tid );

#endif // CSHEAD_H
```
```cpp
//main.cpp
#include "cshead.h"

int main()
{
    cout << "-------CS start-----" << endl;
    pthread_t tid;
    int getReturn;
    getReturn = pthread_create( &tid, nullptr, client, nullptr );
    if( getReturn ){
        cout << "creathe pthread error\n";
        exit( 0 );
    }

    cout << "------serve start-----" << endl;
    serve( tid );

    return 0;
}
```
**客户端**

```cpp
//client.cpp
#include "cshead.h"
#define MAXSIZE 4096

void *client( void *value )
{
    sleep( 2 );

    int sockfd;
    char sendLine[ MAXSIZE ];
    char serIp[] = "127.0.0.1";//服务器IP地址
    int getReturn;
    struct sockaddr_in seraddr;//套接字结构体

    sockfd = socket( AF_INET, SOCK_STREAM, 0 );
    if( sockfd < 0 ) {
        cout << "socket creath faile from client" << endl;
        exit( 0 );
    }

    memset( &seraddr, 0, sizeof ( seraddr ) );
    seraddr.sin_family = AF_INET;
    seraddr.sin_port = htons( 6666 );//服务器端口号
    getReturn =  inet_pton( AF_INET, serIp, &seraddr.sin_addr );//点十分到二进制转换
    if( getReturn <= 0 ) {
        cout << "inet_pton failefrom client" << endl;
        exit( 1 );
    }

    getReturn = connect( sockfd, ( struct sockaddr* )&seraddr, sizeof ( seraddr ) );//套接字连接，需要进行结构体强制转换
    if( getReturn < 0 ) {
        cout << "connect faile from client" << endl;
        exit( 0 );
    }

    cout << "----Successfully connected to the server " << endl
         << "  please input string send to server---" << endl;
    fgets( sendLine, MAXSIZE, stdin );//获取标准输入
    if( send( sockfd, sendLine, strlen( sendLine ), 0 ) < 0 ) {//向套接字发送数据
        cout << "send faile from client" << endl;
        exit( 0 );
    }
    close( sockfd );//关闭套接字
    pthread_exit( ( void* )0 );
}
```
**服务器**

```cpp
//server.cpp
#include "cshead.h"

#define MaxLINE 4096
#define MaxBuff 4096

void serve( pthread_t tid )
{
    int listenfd, connfd;//监听套接字 连接套接字
    int getReturn;
    char buff[ MaxBuff ];//缓冲区
    ssize_t byteSize;//接收的字节数
    struct sockaddr_in servaddr;//套接字结构体

    listenfd = socket( AF_INET, SOCK_STREAM, 0 );//创建套接字：IPV4协议 TCP套接字 自动选择协议
    if( listenfd == -1 ){
        cout << "creath socket faile from server" << endl;
        exit( 0 );
    }

    memset( &servaddr, 0, sizeof ( servaddr ) );//初始化套接字结构体
    servaddr.sin_family = AF_INET;//IPV4协议
    servaddr.sin_addr.s_addr = htonl( INADDR_ANY );//多网卡
    servaddr.sin_port = htons( 6666 );//服务器端口号

    getReturn =  bind( listenfd, ( struct sockaddr* )&servaddr, sizeof ( servaddr ) );//将结构体信息绑定到该套接字上
    if( getReturn == -1 ){
        cout << "bind socket faile from server" << endl;
        exit( 0 );
    }

    getReturn = listen( listenfd, 10 );//创建监听套接字 监听指定端口的请求，10个请求队列
    if( getReturn == -1 ){
        cout << "listen socket faile from server" << endl;
        exit( 0 );
    }

    cout << "------serve waiting client request---------" << endl;
    int countClient = 0;
    while ( countClient != 1 ) {
        connfd = accept( listenfd, ( struct sockaddr* )nullptr, nullptr );//等待客户端请求，连接成功创建连接套接字
        if( connfd == -1 ){
            cout << "accept faile from server" << endl;
            continue;
        }
        ++countClient;
        byteSize = recv( connfd, buff, MaxLINE, 0 );//利用连接套接字，读取缓冲区的字节数
        buff[ byteSize ] = '\0';
        string receStr( buff );
        cout << "recv msg from client: "<< receStr << endl;
        close( connfd );//关闭连接套接字
        pthread_join( tid, nullptr );//等待子线程退出
    }
    close( listenfd );//关闭监听套接字
}

```



# 进程间通讯

## 共享内存

**写入数据**

```cpp
#include <iostream>
#include "shareMemory.h"
#include <stdlib.h>
#include <cstring>
#include <error.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <unistd.h>

using namespace std;
int main(int argc, char *argv[])
{
    int shmid; //获得的内存ID
    key_t key = ftok( "./", 425 );

    shmid = shmget( key, sizeof( shareMemoryStruct ), 0666 | IPC_CREAT  );//申请一块共享内存
    if( shmid == -1 ) {
        cout << "shmget faile error number: " << endl;
            //<< error( STDERR_FILENO ) << endl;
         exit( EXIT_FAILURE );
    }
    cout << "shared memory address is: "<< shmid << endl;
    void *sharedMermory = NULL; //把该共享内存映射到本进程的地址空间
    sharedMermory = shmat( shmid, 0, 0 );//映射共享内存
    if( sharedMermory == ( void* )-1 ) {
        cout << "shmat faile error number: " << endl;
        exit( EXIT_FAILURE );
    }

    cout << "shared Memory attached at: " << &sharedMermory << endl; //输出映射的地址
    shareMemoryStruct *shMerPtr = ( shareMemoryStruct* )sharedMermory;//获得指向共享内存的指针
    memset( shMerPtr, 0, sizeof( *shMerPtr ) );
    shMerPtr->write = 1;

    char buffer[ MAXSIZE ]; //输入缓冲区
    while( true ) {
        while( shMerPtr->write == 1 ) {
            cout << "waite consume sleep 2 second" << endl; //等待消费者进程启动允许写数据
            sleep( 2 );
        }
        cout << "input string" << endl;
        cin >> buffer; //获取标准输入数据
        strncpy( shMerPtr->buff, buffer, sizeof( buffer ) ); //写到共享内存中
        shMerPtr->write = 1;//消费者进程读取数据标记

        if( strncmp( shMerPtr->buff, "end", 3 ) == 0 ) //结束字符
            break;
    }

    if( shmdt( sharedMermory ) == -1 ) { //分离共享内存映射
        cout << "shmdt faile" << endl;
        exit( EXIT_FAILURE );
    }

    return 0;
}
```

**读取数据**

```cpp
#include <iostream>
#include "shareMemory.h"
#include <stdlib.h>
#include <cstring>
#include <error.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <unistd.h>


using namespace std;
int main(int argc, char *argv[])
{
    int shmid; //获得的内存ID
    key_t key = ftok( "./", 425 );

    shmid = shmget( key, sizeof( shareMemoryStruct ), 0666 | IPC_CREAT  );//申请一块共享内存
    if( shmid == -1 ) {
        cout << "shmget faile error number: " << endl;
            //<< error( STDERR_FILENO ) << endl;
         exit( EXIT_FAILURE );
    }

        void *sharedMermory = NULL; //把该共享内存映射到本进程的地址空间
    sharedMermory = shmat( shmid, 0, 0 );//映射共享内存
    if( sharedMermory == ( void* )-1 ) {
        cout << "shmat faile error number: " << endl;
        exit( EXIT_FAILURE );
    }

    cout << "shared Memory attached at: " << &sharedMermory << endl; //输出映射的地址
    shareMemoryStruct *shMerPtr = ( shareMemoryStruct* )sharedMermory;//获得指向共享内存的指针
    shMerPtr->write = 0;

    while( true ) {
        if( shMerPtr->write == 1 ) {
            write( STDOUT_FILENO, shMerPtr->buff, sizeof( shMerPtr->buff ) );
            cout << endl;
            sleep( 1 );
            shMerPtr->write = 0;
        }
        if( strncmp( shMerPtr->buff, "end", 3 ) == 0 )
            break;
    }

    if( shmdt( sharedMermory ) == -1 ) { //分离共享内存映射
        cout << "shmdt faile" << endl;
        exit( EXIT_FAILURE );
    }

    if ( shmctl( shmid, IPC_RMID, 0 ) == -1 ) {
        cout << "shmctl(IPC_RMID) failed\n";
        exit(EXIT_FAILURE);
    }

    return 0;
}
```



## 信号量

```cpp
#include <iostream>
#include <sys/shm.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

using namespace std;

union semun {
    int val;
};

int main(int argc, char *argv[])
{
    int shmid; //获得的内存ID
    key_t key = ftok( "./", 425 );

    shmid = shmget( key, sizeof( int ), IPC_CREAT | 0666 );
    if( shmid < 0 ) {
        cout << "shmget faile" << endl;
        exit( EXIT_FAILURE );
    }
    cout << "shared memory address is: "<< shmid << endl;

    void *shmemory = shmat( shmid, nullptr, 0 );
    if( shmemory == ( void* ) -1 ) {
        cout << "shmat faile" << endl;
        exit( EXIT_FAILURE );
    }
    cout << "shared Memory attached at: " << &shmemory << endl;

    int *data = ( int* )shmemory;
    *data = -1;

    key_t semKid = ftok( "./", 500 );
    int semid = semget( semKid, 2, IPC_CREAT | 0666 ); //生成2个信号量

    semun semunUnion;
    semunUnion.val = 0;//信号0初值
    semctl( semid, 0, SETVAL, semunUnion );//设置信号0

    semunUnion.val = 1;//信号1初值
    semctl( semid, 1, SETVAL, semunUnion );//设置信号1

    struct sembuf sembufStruct;

    while( true ) {
        sembufStruct.sem_num = 0;//对信号0操作
        sembufStruct.sem_op = -1;//P操作
        sembufStruct.sem_flg = SEM_UNDO;//系统清除信号量
        semop( semid, &sembufStruct, 1 );//读操作造成阻塞

        cout << "you input number is: "<< *data << endl;

        sembufStruct.sem_num = 1;//对信号号1操作
        sembufStruct.sem_op = 1;//V操作
        sembufStruct.sem_flg = SEM_UNDO;
             semop( semid, &sembufStruct, 1 );//写操作

        if( *data == 0 )
            break;
    }

    return 0;
}
```

**写者**

``` cpp
//writer
#include <iostream>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/sem.h>

using namespace std;

union semun {
    int val;
};

int main(int argc, char *argv[])
{
    int shmid; //获得的内存ID
    key_t key = ftok( "./", 425 );

    shmid = shmget( key, sizeof( int ), IPC_CREAT | 0666 );
    if( shmid < 0 ) {
        cout << "shmget faile" << endl;
        exit( EXIT_FAILURE );
    }
    cout << "shared memory address is: "<< shmid << endl;

    void *shmemory = shmat( shmid, nullptr, 0 );
    if( shmemory == ( void* ) -1 ) {
        cout << "shmat faile" << endl;
        exit( EXIT_FAILURE );
    }
    cout << "shared Memory attached at: " << &shmemory << endl;

    int *data = ( int* )shmemory;
    *data = -1;

    key_t semKid = ftok( "./", 500 );
    int semid = semget( semKid, 2,  0666 );

    struct sembuf sembufStruct;
    cout << "input number '0' to end" << endl;
    while( true ) {
        sembufStruct.sem_num = 1;
        sembufStruct.sem_op = -1;
        sembufStruct.sem_flg = SEM_UNDO;
        semop( semid, &sembufStruct, 1 );

        cout << "please input number: ";
        cin >> *data;

        sembufStruct.sem_num = 0;
        sembufStruct.sem_op = 1;
        sembufStruct.sem_flg = SEM_UNDO;
        semop( semid, &sembufStruct, 1 );

        if( *data == 0 )
            break;
    }

    return 0;
}
```



## 管道

**无名管道**

```cpp
#include<iostream>
#include<unistd.h>
#include <wait.h>
#include <string>
#include <stdlib.h>
using namespace std;

#define RD 0
#define WR 1
#define MAXSIZE 1024

int main(  )
{
    pid_t kidPid;
    int fd[ 2 ];
    string str = "Hello pipe";
    char reBuff[ MAXSIZE ] = { 0 };

    pipe( fd ); //创建无名管道
    kidPid = fork();

    if( kidPid < 0 ) {
        cout << "fork faile" << endl;
        exit( 0 );
    }
    else if( kidPid == 0 ) {
        close( fd[ RD ] ); //子进程关闭无名管道的读端
        write( fd[ WR ], str.c_str(), str.length() );//写入数据
        exit( 0 );
    }
    else if( kidPid > 0 ) {
        wait( NULL );
        close( fd[ WR ] );//父进程关闭无名管道的写端
        read( fd[ RD ], reBuff, sizeof( reBuff ) );//读取数据
        string str( reBuff );
        cout << str;
    }

    return 0;
}
```

**有名管道**

```cpp
/*----------------------------------------------------------------

* @Author: Su

* @Description: 读进程

* @Creath Date: 2019-03-29-23.37.13

----------------------------------------------------------------*/

#include<iostream>
#include<unistd.h>
#include <wait.h>
#include <string>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

using namespace std;

#define RD 0
#define WR 1
#define MAXSIZE 1024
#define P_FIFO "./p_fifo"

int main(int argc, char *argv[])
{
    id_t kidPid;
    int fd;
    char reBuff[ MAXSIZE ] = { 0 };
    char *execv_str[] = {"./mkfifo_progress2", NULL };

    kidPid = fork();

    if( kidPid < 0 ) {
        cout << "fork faile" << endl;
        exit( 0 );
    }
    else if( kidPid == 0 ) {
        execv( "./mkfifo_progress2", execv_str ); //写进程启动并创建无名管道
    }
    else if( kidPid > 0 ) {
        cout << "sleep 2 second wait write progress" << endl;
        sleep( 2 ); //保证写进程先执行并阻塞
        fd = open( P_FIFO, O_RDONLY | O_NONBLOCK ); //读方式并且不阻塞方式打开管道
        while( read( fd, reBuff, sizeof( reBuff ) ) <= 0 )//读取数据
        {
            cout << "No Data message from read progress" << endl;;
            sleep( 1 );
        }

        string str( reBuff );
        cout << "rev date from wirte progress: "<< str << endl;
    }

    close(fd);

    return 0;
}

/*----------------------------------------------------------------

* @Author: Su

* @Description:写进程

* @Creath Date: 2019-03-29-23.37.21

----------------------------------------------------------------*/
#include<iostream>
#include<unistd.h>
#include <wait.h>
#include <cstring>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
using namespace std;

#define MAXSIZE 1024
#define P_FIFO "./p_fifo"

int main(int argc, char *argv[])
{
    char writeBuff[ MAXSIZE ] = { 0 };
    int fd;

    if( access( P_FIFO, F_OK ) == 0 ) {
         cout << "rm exist P_FIFO" << endl;
         pid_t kidPid = fork();
         if( kidPid == 0 ) //执行删除文件进程
            execlp( "rm", "-f",  P_FIFO, NULL );
    }

    sleep( 1 ); //让删除文件的进程先执行
    if( mkfifo ( P_FIFO, 0777 ) < 0 ){  //创建无名管道
        cout << "createnamed pipe failed.\n" << endl;
        exit( EXIT_SUCCESS );
    }
    else cout << "create fifo" << endl;

    fd = open( P_FIFO, O_WRONLY ); //以写方式并且阻塞方式打开管道，直到另一进程以读方式打开管道才返回
    if( fd < 0 ) {
        cout << "open faile" << endl;
        exit( EXIT_SUCCESS );
    }

    if( write( fd, "Hello mkfifo", strlen( "Hello mkfifo" ) ) <= 0 ) { //往管道写数据
        cout << "write string faile " << endl;
    }
    else cout << "write successful message from write progress" << endl;

    close(fd);

    return 0;
}

//cout << pathconf( "./P_FiFO", _PC_PIPE_BUF );
```

# 守护进程

```cpp
/**
 * @author Melt
 * @email [example@mail.com]
 * @create date 2019-03-20 16:35:38
 * @modify date 2019-03-20 16:35:38
 * @desc [description]
 * 创建一个守护进程
 */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<fcntl.h>
#include<unistd.h>
#include<sys/wait.h>
#include<sys/types.h>
#include<sys/stat.h>
#define MAXFILE 65535

int main(){
    pid_t pc;
    int i,fd,len;
    char *buf="this is a Dameon\n";
    len = strlen(buf);
    pc = fork(); 

    if(pc<0){
        printf("error fork\n");
        exit(1);
    }else if(pc>0){
        exit(0);
    }
    setsid();

    chdir("/"); 
    
    umask(0); 
    
    for(i=0;i<MAXFILE;i++)
        close(i);
    while(1){
    if((fd=open("/tmp/dameon.log",O_CREAT|O_WRONLY|O_APPEND,0600))<0){
        perror("open");
        exit(1);
    }
    write(fd,buf,len+1);
    close(fd);
    sleep(10);
  }
  return 0;
}
```

# 线程同步互斥

## 线程演示

```cpp
/**
 * @author Melt
 * @email [example@mail.com]
 * @create date 2019-03-03 16:09:58
 * @modify date 2019-03-03 16:09:58
 * @desc [description] use pthread say hello
 *演示线程创建和线程等待
 */

#include <iostream>
#include <string>
#include <pthread.h>
#include <unistd.h>
using namespace std;

struct sayhello_arg //线程调用函数结构体参数
{
    /* data */
    string str;
    int number;
    sayhello_arg( string valueStr, int num ) : str( valueStr ), number( num ){}
};

class sayhello //定义的类
{
private:
    /* data */
public:
    static void *say_hello( void *value ); // 静态函数
    sayhello(/* args */) = default;
    ~sayhello(){}
};

void *sayhello::say_hello( void *value ) //类外静态函数定义
{
    struct sayhello_arg *arg = static_cast<struct sayhello_arg *>(value); //结构体参数强制转换
    //cout << pthread_self() << endl; //返回自身线程的id
    cout << "say_hello funtion: " << ' ' << arg->number << ' ' << arg->str << endl;
    pthread_exit( ( void* )2 ); //子线程的退出返回值
}

int main()
{
    pthread_t tid; //线程ID变量
    pthread_attr_t attr; //线程的参数变量
    int iRet;  //获取返回值
    sayhello_arg arg( "Hello word", 425 ); //结构体参数变量

//    iRet = pthread_attr_init(&attr); //初始化线程参数
//    if( iRet ) {
//        printf(" pthread_attr_init error\n ");
//        return iRet;
//    }

//    iRet = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); //设置线程分离属性
//    if( iRet ) {
//        printf(" pthread_attr_setdetachstat error\n ");
//        return iRet;
//    }

    iRet = pthread_create( &tid, nullptr, sayhello::say_hello, &arg ); //创建带着属性的线程
    if( iRet ) {
        printf(" creathe pthread error\n ");
        return iRet;
    }

    iRet = pthread_detach(tid); //线程创建后进行状态分离
    if( iRet ) {
        printf(" pthread_detach error\n ");
        return iRet;
    }
    sleep( 1 ); //主线程休眠1秒
    cout << "子线程ID: " << tid << endl; //创建线程后的id

    void *retval; //获取子线程的返回值
    iRet = pthread_join( tid, &retval ); //等待子线程退出
    if ( iRet ) {
        printf("pthread_join error or pthread detached\n");
        return iRet;
    }
    printf("retval = %ld\n", static_cast<long*>(retval)  ); //输出子线程的退出值
    return 0;
}

```

## 读写锁

```cpp
/*
 *
 * 读写锁
 *
 */

#include <iostream>
#include <pthread.h>
#include <unistd.h>
using namespace std;

#define THREADNUM 5

static pthread_rwlock_t rwlock;
void *readers(void *arg){  //读者函数

    pthread_rwlock_rdlock(&rwlock); //获取读锁
    printf("reader %ld got the lock\n", (long)arg);
    pthread_rwlock_unlock(&rwlock); //解锁

    pthread_exit( nullptr );

}

void *writers(void *arg){ //写者函数

    pthread_rwlock_wrlock(&rwlock); //获得写锁
    printf("writer %ld got the lock\n", (long)arg);
    pthread_rwlock_unlock(&rwlock);

    pthread_exit((void*)0);
}

int main(int argc, char **argv){
    int iRet, i;
    pthread_t writer_id, reader_id; //写者线程 读者线程
    pthread_attr_t attr; //线程属性

    int nreadercount = 1, nwritercount = 1; //读者个数 写者个数

    iRet = pthread_rwlock_init(&rwlock, nullptr ); //动态初始化读写锁
    if (iRet) {
        fprintf(stderr, "init lock failed\n");
        return iRet;
    }

    pthread_attr_init(&attr); //线程属性初始化
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); //设置线程分离

    for (i = 0; i < THREADNUM; i++){
        //创建三个读者线程
        if (i % 3) {
            pthread_create(&reader_id, &attr, readers, (void *)nreadercount);
            printf("create reader %d\n", nreadercount++);
        }
        //创建俩个写者线程
        else {
            pthread_create(&writer_id, &attr, writers, (void *)nwritercount);
            printf("create writer %d\n", nwritercount++);
        }
    }
    sleep(5); /*sleep是为了等待另外的线程的执行*/

    return 0;
}
```

## 互斥锁

```cpp
/*
 *
 *模拟火车售票系统 互斥锁
 *
 */

#include <iostream>
#include <string>
#include <pthread.h>
#include <unistd.h>
using namespace std;

static int total_ticket_num = 20; //火车总票数
static pthread_mutex_t mutex; //互斥锁全局变量
void *sell_ticket(void *arg){  //线程循环函数
    for(int i=0; i<20; i++){
        pthread_mutex_lock( &mutex );
        if( total_ticket_num > 0 ){
            sleep(1);
            printf("sell the %dth ticket by %ld\n", 20-total_ticket_num+1, pthread_self() ); //成功卖出一张票
            total_ticket_num--; //票数减一
        }
        //cout << "after sale funtion ID: " << pthread_self() << endl;
        pthread_mutex_unlock( &mutex );
    }
    cout << "pthread end ID: " << pthread_self() << endl; //线程结束输出
    return nullptr;
}

void *sell_ticket2( void *arg )
{
    for ( int i = 0; i < 10 ; ++i ) {
        if( pthread_mutex_trylock( &mutex ) == EBUSY ) //尝试获得互斥锁
            cout << "mutex using by other pthread\n";
        else {
            if( total_ticket_num > 0 ){
                sleep(1);
                printf("sell the %dth ticket by %ld\n", 20-total_ticket_num+1, pthread_self() ); //成功卖出一张票
                total_ticket_num--; //票数减一
            }
        }
         pthread_mutex_unlock( &mutex );
    }
    cout << "pthread end ID: " << pthread_self() << endl; //线程结束输出
    return nullptr;
}

int main(){
    int iRet;
    int i=0;
    const int pthreadCount = 2; //线程个数
    pthread_t tids[ pthreadCount ]; //创建2个线程
    pthread_mutex_init( &mutex, nullptr ); //互斥锁初始化

    for( i=0; i<pthreadCount;  ){
        iRet = pthread_create(&tids[ i++ ], nullptr, &sell_ticket, nullptr ); //执行函数1
        if(iRet){
            printf("pthread_create error, iRet=%d\n",iRet);
            return iRet;
        }

        iRet = pthread_create(&tids[ i++ ], nullptr, &sell_ticket2, nullptr ); //执行函数2
        if(iRet){
            printf("pthread_create error, iRet=%d\n",iRet);
            return iRet;
        }
    }

    sleep(10); //主线程休眠20秒
    void *retval;
    for( i=0; i<pthreadCount; i++ ){
        iRet=pthread_join(tids[i], &retval ); //等待子线程
        if(iRet){
            printf("tid=%d join error, iRet=%d\n", tids[i], iRet );
            return iRet;
        }
        printf("retval=%ld\n", (long*)retval );
    }
    cout << "ticket Remaining: " << total_ticket_num << endl;
    pthread_mutex_destroy( &mutex );  //销毁互斥锁

    return 0;
}
```

## 条件变量

```cpp
/*
 *
 *模拟出租车 条件变量
 *
 */
#include <iostream>
#include <string>
#include <unistd.h>
#include <pthread.h>
#include <error.h>
using namespace std;

static pthread_cond_t taxiCond = PTHREAD_COND_INITIALIZER; //初始化条件变量
static pthread_mutex_t taxiMutex = PTHREAD_MUTEX_INITIALIZER; //初始化互斥锁
int travelerCound = 0; //乘客的数量

void *traveler_arrive( void *name )
{
    cout << "traveler name: " << static_cast<char*>(name) << " need a taxi"<< endl;
    pthread_mutex_lock( &taxiMutex ); //上锁
    ++travelerCound; //上锁后再增加一位乘客
    pthread_cond_wait( &taxiCond, &taxiMutex ); //等待条件变量改变，调用时候必须本线程手动上锁，在线程挂起阻塞时解锁，当收到激活信号时 //这里的条件变量是要一辆出租车
    //重新上锁，执行想要的操作，最后手动解锁
    cout << "traveler name: " << static_cast<char*>(name) << " go to a taxi"<< endl;
    pthread_mutex_unlock( &taxiMutex );//解锁

    pthread_exit( nullptr );
}

void *taxi_arrive( void *name )
{
    cout << "taxi name: " << static_cast<char*>(name) << " need a traveler"<< endl;
    while( true ){
        pthread_mutex_lock( &taxiMutex );
        if( travelerCound > 0 ) {
            pthread_cond_signal( &taxiCond ); //发生激活信号给等待次信号变量而阻塞的线程
            pthread_mutex_unlock( &taxiMutex ); //解锁再退出
            break;
        }
        pthread_mutex_unlock( &taxiMutex );
    }
    cout << "a car end" << endl;
    pthread_exit( nullptr );
}

int main()
{
    int Ret;
    const int pthreadCount = 3;
    pthread_t tid[ pthreadCount ];

    for ( int i = 0; i < pthreadCount; ++i ) {
        Ret = pthread_create( &tid[ i++ ], nullptr, taxi_arrive, ( void* )"BMW" );
        sleep( 1 );
        Ret = pthread_create( &tid[ i++ ], nullptr, traveler_arrive, ( void* )"Melt" );
        sleep( 3 );
        Ret = pthread_create( &tid[ i++ ], nullptr, taxi_arrive, ( void* )"QQ" );
    }
    sleep( 1 );
    void *RetValue;
    for ( int i = 0; i < pthreadCount; ++i ) {
        pthread_join( tid[ i ], &RetValue );
        cout << "pthread return value: " << RetValue << endl;
    }
    pthread_cond_destroy( &taxiCond );
    pthread_mutex_destroy( &taxiMutex );

    return 0;
}
```

## 信号量

```cpp
/*
 * 模拟窗口服务 信号量
 *
 */

#include <iostream>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
using namespace std;

#define CUSTOMER_NUM 10 //顾客人数

static sem_t sem; //信号量
void * get_service(void *thread_id){

   int customer_id = *((int *)thread_id); //保存顾客ID

    if(sem_wait(&sem) == 0) {  //信号非0则可以进入临界区，多个线程可以进入
        usleep(100); /* service time: 100ms */
        printf("customer %d receive service ...\n", customer_id);
        printf("customer %d leaving service ...\n", customer_id);
        sem_post(&sem); //信号量加1
    }
}

int main(int argc, char *argv[]){
    int i, iRet;

    sem_init(&sem, 0, 2); //初始化信号量，0表示当前进程的局部信号，初值为2表示最多接受两名顾客服务
    pthread_t customers[CUSTOMER_NUM]; //


    for(i = 0; i < CUSTOMER_NUM; i++){
        int customer_id = i; //顾客的ID
        iRet = pthread_create(&customers[i], nullptr, get_service, &customer_id); //创建顾客线程

        if(iRet){
            perror("pthread_create");
            return iRet;
        }
        else{
            printf("Customer %d arrived.\n", i);
        }

        usleep(10);
    }

    int j;
    for(j = 0; j < CUSTOMER_NUM; j++) {
            pthread_join(customers[j], nullptr);
        }

    sem_destroy(&sem);

    return 0;
}
```

